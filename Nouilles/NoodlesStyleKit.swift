//
//  NoodlesStyleKit.swift
//  Nouilles
//
//  Created by Denis Ricard on 2017-02-04.
//  Copyright Â© 2017 Hexaedre. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class NoodlesStyleKit : NSObject {

    //// Cache

    private struct Cache {
        static let timer1: UIColor = UIColor(red: 0.994, green: 0.967, blue: 0.599, alpha: 1.000)
        static let timer2: UIColor = NoodlesStyleKit.timer1.shadow(withLevel: 0.1)
        static let timerBkg: UIColor = UIColor(red: 0.909, green: 0.685, blue: 0.075, alpha: 1.000)
        static let baseGreen: UIColor = UIColor(red: 0.602, green: 0.733, blue: 0.392, alpha: 1.000)
        static let baseYellow: UIColor = UIColor(red: 0.974, green: 0.932, blue: 0.127, alpha: 1.000)
        static let baseOrange: UIColor = UIColor(red: 1.000, green: 0.782, blue: 0.122, alpha: 1.000)
        static let lighterGreen: UIColor = NoodlesStyleKit.baseGreen.highlight(withLevel: 0.3)
        static let darkerGreen: UIColor = NoodlesStyleKit.baseGreen.shadow(withLevel: 0.3)
        static let lighterYellow: UIColor = NoodlesStyleKit.baseYellow.withSaturation(0.1)
        static let darkerYellow: UIColor = NoodlesStyleKit.baseYellow.shadow(withLevel: 0.1)
        static let lighterOrange: UIColor = NoodlesStyleKit.baseOrange.highlight(withLevel: 0.3)
        static let darkerOrange: UIColor = NoodlesStyleKit.baseOrange.shadow(withLevel: 0.3)
        static let mediumYellow: UIColor = NoodlesStyleKit.baseYellow.withSaturation(0.2)
        static let timerGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [NoodlesStyleKit.timer1.cgColor, NoodlesStyleKit.timerBkg.cgColor] as CFArray, locations: [0, 1])!
        static var imageOfScanFailure: UIImage?
        static var scanFailureTargets: [AnyObject]?
        static var imageOfScanSuccess: UIImage?
        static var scanSuccessTargets: [AnyObject]?
        static var imageOfScanProcessing: UIImage?
        static var scanProcessingTargets: [AnyObject]?
        static var imageOfNouille: UIImage?
        static var nouilleTargets: [AnyObject]?
        static var imageOfMealSizeIndicator: UIImage?
        static var mealSizeIndicatorTargets: [AnyObject]?
        static var imageOfMealSizeIndicatorSD: UIImage?
        static var mealSizeIndicatorSDTargets: [AnyObject]?
        static var imageOfOnHandIndicator: UIImage?
        static var onHandIndicatorTargets: [AnyObject]?
        static var imageOfOnHandIndicatorEmpty: UIImage?
        static var onHandIndicatorEmptyTargets: [AnyObject]?
        static var imageOfPause: UIImage?
        static var pauseTargets: [AnyObject]?
        static var imageOfPlay: UIImage?
        static var playTargets: [AnyObject]?
        static var imageOfCancel: UIImage?
        static var cancelTargets: [AnyObject]?
        static var imageOfCancelSelected: UIImage?
        static var cancelSelectedTargets: [AnyObject]?
        static var imageOfNoodlePlaceholderImage: UIImage?
        static var noodlePlaceholderImageTargets: [AnyObject]?
    }

    //// Colors

    public dynamic class var timer1: UIColor { return Cache.timer1 }
    public dynamic class var timer2: UIColor { return Cache.timer2 }
    public dynamic class var timerBkg: UIColor { return Cache.timerBkg }
    public dynamic class var baseGreen: UIColor { return Cache.baseGreen }
    public dynamic class var baseYellow: UIColor { return Cache.baseYellow }
    public dynamic class var baseOrange: UIColor { return Cache.baseOrange }
    public dynamic class var lighterGreen: UIColor { return Cache.lighterGreen }
    public dynamic class var darkerGreen: UIColor { return Cache.darkerGreen }
    public dynamic class var lighterYellow: UIColor { return Cache.lighterYellow }
    public dynamic class var darkerYellow: UIColor { return Cache.darkerYellow }
    public dynamic class var lighterOrange: UIColor { return Cache.lighterOrange }
    public dynamic class var darkerOrange: UIColor { return Cache.darkerOrange }
    public dynamic class var mediumYellow: UIColor { return Cache.mediumYellow }

    //// Gradients

    public dynamic class var timerGradient: CGGradient { return Cache.timerGradient }

    //// Drawing Methods

    public dynamic class func drawTimerAnimation(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 200), resizing: ResizingBehavior = .aspectFit, timerRatio: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 200, height: 200), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 200, y: resizedFrame.height / 200)



        //// Variable Declarations
        let timerDash: CGFloat = 6 + timerRatio * 478
        let spinArrow: CGFloat = -timerRatio * 360 * 8

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 99.5, y: 32.44))
        bezierPath.addCurve(to: CGPoint(x: 32.47, y: 100.5), controlPoint1: CGPoint(x: 55.16, y: 32.95), controlPoint2: CGPoint(x: 32.47, y: 68.53))
        bezierPath.addCurve(to: CGPoint(x: 99.5, y: 169.59), controlPoint1: CGPoint(x: 33.5, y: 135.56), controlPoint2: CGPoint(x: 57.22, y: 169.59))
        bezierPath.addCurve(to: CGPoint(x: 168.59, y: 100.5), controlPoint1: CGPoint(x: 141.78, y: 169.59), controlPoint2: CGPoint(x: 168.59, y: 132.39))
        bezierPath.addCurve(to: CGPoint(x: 99.5, y: 32.44), controlPoint1: CGPoint(x: 168.59, y: 68.61), controlPoint2: CGPoint(x: 144.7, y: 32.92))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 182, y: 100.5))
        bezierPath.addCurve(to: CGPoint(x: 99.5, y: 183), controlPoint1: CGPoint(x: 182, y: 146.06), controlPoint2: CGPoint(x: 145.06, y: 183))
        bezierPath.addCurve(to: CGPoint(x: 17, y: 100.5), controlPoint1: CGPoint(x: 53.94, y: 183), controlPoint2: CGPoint(x: 17, y: 146.06))
        bezierPath.addCurve(to: CGPoint(x: 52.56, y: 32.65), controlPoint1: CGPoint(x: 17, y: 72.38), controlPoint2: CGPoint(x: 31.07, y: 47.54))
        bezierPath.addCurve(to: CGPoint(x: 99.5, y: 18), controlPoint1: CGPoint(x: 65.88, y: 23.41), controlPoint2: CGPoint(x: 82.06, y: 18))
        bezierPath.addCurve(to: CGPoint(x: 182, y: 100.5), controlPoint1: CGPoint(x: 145.06, y: 18), controlPoint2: CGPoint(x: 182, y: 54.94))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(NoodlesStyleKit.timerGradient, start: CGPoint(x: 99.5, y: 18), end: CGPoint(x: 99.5, y: 183), options: [])
        context.restoreGState()


        //// timerMask Drawing
        context.saveGState()
        context.translateBy(x: 100, y: 100)
        context.rotate(by: -90 * CGFloat.pi/180)

        let timerMaskPath = UIBezierPath()
        timerMaskPath.move(to: CGPoint(x: 75, y: -0.75))
        timerMaskPath.addCurve(to: CGPoint(x: -0.75, y: 75), controlPoint1: CGPoint(x: 75, y: 41.09), controlPoint2: CGPoint(x: 41.09, y: 75))
        timerMaskPath.addCurve(to: CGPoint(x: -76.5, y: -0.75), controlPoint1: CGPoint(x: -42.59, y: 75), controlPoint2: CGPoint(x: -76.5, y: 41.09))
        timerMaskPath.addCurve(to: CGPoint(x: -0.75, y: -76.5), controlPoint1: CGPoint(x: -76.5, y: -42.59), controlPoint2: CGPoint(x: -42.59, y: -76.5))
        timerMaskPath.addCurve(to: CGPoint(x: 75, y: -0.75), controlPoint1: CGPoint(x: 41.09, y: -76.5), controlPoint2: CGPoint(x: 75, y: -42.59))
        timerMaskPath.close()
        UIColor.black.setStroke()
        timerMaskPath.lineWidth = 27
        timerMaskPath.lineCapStyle = .round
        context.saveGState()
        context.setLineDash(phase: 4, lengths: [timerDash, 478])
        timerMaskPath.stroke()
        context.restoreGState()

        context.restoreGState()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 86.5, y: 11.5, width: 27, height: 27))
        NoodlesStyleKit.darkerGreen.setFill()
        ovalPath.fill()
        UIColor.black.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()


        //// Group 2
        context.saveGState()
        context.translateBy(x: 100, y: 25)
        context.rotate(by: -spinArrow * CGFloat.pi/180)



        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: -6.35, y: -0.25, width: 13, height: 1), cornerRadius: 0.5)
        NoodlesStyleKit.baseOrange.setStroke()
        rectangle2Path.lineWidth = 2
        rectangle2Path.stroke()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 0.15, y: -0.25)
        context.rotate(by: -45 * CGFloat.pi/180)

        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: -7, y: -0.02, width: 13, height: 1), cornerRadius: 0.5)
        NoodlesStyleKit.baseOrange.setStroke()
        rectanglePath.lineWidth = 2
        rectanglePath.stroke()

        context.restoreGState()


        //// Rectangle 3 Drawing
        context.saveGState()
        context.translateBy(x: 0.15, y: -0.25)
        context.rotate(by: 45 * CGFloat.pi/180)

        let rectangle3Path = UIBezierPath(roundedRect: CGRect(x: -6, y: 0.1, width: 13, height: 1), cornerRadius: 0.5)
        NoodlesStyleKit.baseOrange.setStroke()
        rectangle3Path.lineWidth = 2
        rectangle3Path.stroke()

        context.restoreGState()


        //// Rectangle 4 Drawing
        context.saveGState()
        context.translateBy(x: -0.35, y: 0.5)
        context.rotate(by: -90 * CGFloat.pi/180)

        let rectangle4Path = UIBezierPath(roundedRect: CGRect(x: -6, y: -0.15, width: 13, height: 1), cornerRadius: 0.5)
        NoodlesStyleKit.baseOrange.setStroke()
        rectangle4Path.lineWidth = 2
        rectangle4Path.stroke()

        context.restoreGState()



        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawScanFailure(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 75, height: 75), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 75, height: 75), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 75, y: resizedFrame.height / 75)


        //// Color Declarations
        let failure = UIColor(red: 0.896, green: 0.200, blue: 0.200, alpha: 1.000)
        let failureCross = failure.withBrightness(0.5)

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 4, width: 67, height: 67))
        failure.setFill()
        ovalPath.fill()
        failureCross.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 37.45, y: 37.55)
        context.rotate(by: -45 * CGFloat.pi/180)

        let rectanglePath = UIBezierPath(rect: CGRect(x: -24.5, y: -3, width: 49, height: 6))
        failureCross.setFill()
        rectanglePath.fill()

        context.restoreGState()


        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: 37.45, y: 37.55)
        context.rotate(by: -135 * CGFloat.pi/180)

        let rectangle2Path = UIBezierPath(rect: CGRect(x: -24.5, y: -3, width: 49, height: 6))
        failureCross.setFill()
        rectangle2Path.fill()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawScanSuccess(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 75, height: 75), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 75, height: 75), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 75, y: resizedFrame.height / 75)


        //// Color Declarations
        let success = UIColor(red: 0.742, green: 0.927, blue: 0.079, alpha: 1.000)
        let successCheck = success.shadow(withLevel: 0.6)

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 4, width: 67, height: 67))
        success.setFill()
        ovalPath.fill()
        successCheck.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 42.97, y: 40.1)
        context.rotate(by: -60 * CGFloat.pi/180)

        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: -21.56, y: -3, width: 43.11, height: 6), cornerRadius: 3)
        successCheck.setFill()
        rectanglePath.fill()

        context.restoreGState()


        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: 28.03, y: 51.14)
        context.rotate(by: -135 * CGFloat.pi/180)

        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: -9.78, y: -3, width: 19.55, height: 6), cornerRadius: 3)
        successCheck.setFill()
        rectangle2Path.fill()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawScanProcessing(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 75, height: 75), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 75, height: 75), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 75, y: resizedFrame.height / 75)


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 4, width: 67, height: 67))
        NoodlesStyleKit.timer1.setFill()
        ovalPath.fill()
        NoodlesStyleKit.timerBkg.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()


        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: 24, y: 37)

        let rectangle2Path = UIBezierPath(rect: CGRect(x: -3.06, y: -3, width: 6.12, height: 6))
        NoodlesStyleKit.timerBkg.setFill()
        rectangle2Path.fill()

        context.restoreGState()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 38, y: 37)

        let rectanglePath = UIBezierPath(rect: CGRect(x: -3.06, y: -3, width: 6.12, height: 6))
        NoodlesStyleKit.timerBkg.setFill()
        rectanglePath.fill()

        context.restoreGState()


        //// Rectangle 3 Drawing
        context.saveGState()
        context.translateBy(x: 51, y: 37)

        let rectangle3Path = UIBezierPath(rect: CGRect(x: -3.06, y: -3, width: 6.12, height: 6))
        NoodlesStyleKit.timerBkg.setFill()
        rectangle3Path.fill()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawNouille(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 40, height: 40), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 40, height: 40), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 40, y: resizedFrame.height / 40)


        //// Color Declarations
        let mediumOrange = NoodlesStyleKit.baseOrange.highlight(withLevel: 0.1)

        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 40, height: 40))
        NoodlesStyleKit.lighterYellow.setFill()
        rectangle4Path.fill()


        //// Group 2
        //// Group
        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: 10.61, y: 19.5)

        let rectangle2Path = UIBezierPath(rect: CGRect(x: -5.05, y: -11, width: 10.1, height: 22))
        NoodlesStyleKit.baseOrange.setFill()
        rectangle2Path.fill()

        context.restoreGState()


        //// Rectangle 3 Drawing
        context.saveGState()
        context.translateBy(x: 30.77, y: 20.14)

        let rectangle3Path = UIBezierPath(rect: CGRect(x: -5.05, y: -10.49, width: 10.1, height: 20.98))
        NoodlesStyleKit.baseOrange.setFill()
        rectangle3Path.fill()

        context.restoreGState()


        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalIn: CGRect(x: 5.55, y: 4, width: 10, height: 10))
        NoodlesStyleKit.lighterOrange.setFill()
        oval3Path.fill()


        //// Oval 4 Drawing
        let oval4Path = UIBezierPath(ovalIn: CGRect(x: 26, y: 24.5, width: 10, height: 10))
        NoodlesStyleKit.lighterOrange.setFill()
        oval4Path.fill()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 20.79, y: 19.21)
        context.rotate(by: -45 * CGFloat.pi/180)

        let rectanglePath = UIBezierPath(rect: CGRect(x: -5, y: -14.5, width: 10, height: 29))
        NoodlesStyleKit.lighterOrange.setFill()
        rectanglePath.fill()

        context.restoreGState()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5.7, y: 24.25, width: 10, height: 10))
        NoodlesStyleKit.baseOrange.setFill()
        ovalPath.fill()
        NoodlesStyleKit.lighterOrange.setStroke()
        ovalPath.lineWidth = 0.5
        ovalPath.stroke()


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: 25.75, y: 4, width: 10, height: 10))
        NoodlesStyleKit.baseOrange.setFill()
        oval2Path.fill()
        NoodlesStyleKit.lighterOrange.setStroke()
        oval2Path.lineWidth = 0.5
        oval2Path.stroke()


        //// Oval 5 Drawing
        let oval5Path = UIBezierPath(ovalIn: CGRect(x: 27.25, y: 5.5, width: 7, height: 7))
        NoodlesStyleKit.lighterOrange.setFill()
        oval5Path.fill()
        NoodlesStyleKit.lighterOrange.setStroke()
        oval5Path.lineWidth = 0.5
        oval5Path.stroke()


        //// Oval 6 Drawing
        let oval6Path = UIBezierPath(ovalIn: CGRect(x: 7.25, y: 25.75, width: 7, height: 7))
        NoodlesStyleKit.lighterOrange.setFill()
        oval6Path.fill()
        NoodlesStyleKit.lighterOrange.setStroke()
        oval6Path.lineWidth = 0.5
        oval6Path.stroke()






        //// Oval 7 Drawing
        let oval7Path = UIBezierPath()
        oval7Path.move(to: CGPoint(x: 7.71, y: 11.87))
        oval7Path.addCurve(to: CGPoint(x: 6.5, y: 9), controlPoint1: CGPoint(x: 6.96, y: 11.14), controlPoint2: CGPoint(x: 6.5, y: 10.12))
        oval7Path.addCurve(to: CGPoint(x: 10.5, y: 5), controlPoint1: CGPoint(x: 6.5, y: 6.79), controlPoint2: CGPoint(x: 8.29, y: 5))
        oval7Path.addCurve(to: CGPoint(x: 13.39, y: 6.23), controlPoint1: CGPoint(x: 11.64, y: 5), controlPoint2: CGPoint(x: 12.66, y: 5.47))
        mediumOrange.setStroke()
        oval7Path.lineWidth = 1
        oval7Path.lineCapStyle = .round
        oval7Path.stroke()


        //// Oval 8 Drawing
        context.saveGState()
        context.translateBy(x: 35, y: 33.5)
        context.rotate(by: -180 * CGFloat.pi/180)

        let oval8Path = UIBezierPath()
        oval8Path.move(to: CGPoint(x: 1.21, y: 6.87))
        oval8Path.addCurve(to: CGPoint(x: 0, y: 4), controlPoint1: CGPoint(x: 0.46, y: 6.14), controlPoint2: CGPoint(x: 0, y: 5.12))
        oval8Path.addCurve(to: CGPoint(x: 4, y: 0), controlPoint1: CGPoint(x: 0, y: 1.79), controlPoint2: CGPoint(x: 1.79, y: 0))
        oval8Path.addCurve(to: CGPoint(x: 6.89, y: 1.23), controlPoint1: CGPoint(x: 5.14, y: 0), controlPoint2: CGPoint(x: 6.16, y: 0.47))
        mediumOrange.setStroke()
        oval8Path.lineWidth = 1
        oval8Path.lineCapStyle = .round
        oval8Path.stroke()

        context.restoreGState()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 35, y: 15))
        bezierPath.addCurve(to: CGPoint(x: 35, y: 25), controlPoint1: CGPoint(x: 35, y: 25), controlPoint2: CGPoint(x: 35, y: 25))
        bezierPath.addLine(to: CGPoint(x: 35, y: 25))
        mediumOrange.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.lineCapStyle = .round
        bezierPath.stroke()


        //// Bezier 2 Drawing
        context.saveGState()
        context.translateBy(x: 24.2, y: 17.12)
        context.rotate(by: -45 * CGFloat.pi/180)

        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 0, y: -14.67))
        bezier2Path.addCurve(to: CGPoint(x: 0, y: 14.32), controlPoint1: CGPoint(x: 0, y: 14.32), controlPoint2: CGPoint(x: 0, y: 14.32))
        bezier2Path.addLine(to: CGPoint(x: 0, y: 14.32))
        mediumOrange.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.lineCapStyle = .round
        bezier2Path.stroke()

        context.restoreGState()


        //// Bezier 3 Drawing
        context.saveGState()
        context.translateBy(x: 17.2, y: 21.55)
        context.rotate(by: -45 * CGFloat.pi/180)

        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: -0.01, y: -13.52))
        bezier3Path.addCurve(to: CGPoint(x: -0.01, y: 16.18), controlPoint1: CGPoint(x: -0.01, y: 16.18), controlPoint2: CGPoint(x: -0.01, y: 16.18))
        bezier3Path.addLine(to: CGPoint(x: -0.01, y: 16.18))
        mediumOrange.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.lineCapStyle = .round
        bezier3Path.stroke()

        context.restoreGState()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 6, y: 15))
        bezier4Path.addCurve(to: CGPoint(x: 6, y: 25), controlPoint1: CGPoint(x: 6, y: 25), controlPoint2: CGPoint(x: 6, y: 25))
        bezier4Path.addLine(to: CGPoint(x: 6, y: 25))
        mediumOrange.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.lineCapStyle = .round
        bezier4Path.stroke()
        
        context.restoreGState()

    }

    public dynamic class func drawMealSizeIndicator(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 40, height: 40), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 40, height: 40), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 40, y: resizedFrame.height / 40)


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: 40, height: 40))
        NoodlesStyleKit.darkerGreen.setFill()
        ovalPath.fill()


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: 3, y: 3, width: 34, height: 34))
        NoodlesStyleKit.baseYellow.setFill()
        oval2Path.fill()
        
        context.restoreGState()

    }

    public dynamic class func drawMealSizeIndicatorSD(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 40, height: 40), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 40, height: 40), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 40, y: resizedFrame.height / 40)


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: 40, height: 40))
        NoodlesStyleKit.darkerGreen.setFill()
        ovalPath.fill()


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath()
        oval2Path.move(to: CGPoint(x: 3, y: 20))
        oval2Path.addCurve(to: CGPoint(x: 20, y: 3), controlPoint1: CGPoint(x: 3, y: 10.61), controlPoint2: CGPoint(x: 10.61, y: 3))
        oval2Path.addCurve(to: CGPoint(x: 20, y: 20), controlPoint1: CGPoint(x: 20, y: 3), controlPoint2: CGPoint(x: 20, y: 10.61))
        NoodlesStyleKit.baseYellow.setFill()
        oval2Path.fill()
        
        context.restoreGState()

    }

    public dynamic class func drawRatingIndicator(frame: CGRect = CGRect(x: 0, y: 0, width: 95, height: 20), rating: CGFloat = 2) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!


        //// Variable Declarations
        let ratingRatio: CGFloat = (5 - rating) / 5.0

        //// Star Drawing
        context.saveGState()
        context.setBlendMode(.colorBurn)

        let starPath = UIBezierPath()
        starPath.move(to: CGPoint(x: frame.minX + 9.5, y: frame.minY + 0.10000 * frame.height))
        starPath.addLine(to: CGPoint(x: frame.minX + 12.67, y: frame.minY + 0.33157 * frame.height))
        starPath.addLine(to: CGPoint(x: frame.minX + 18.06, y: frame.minY + 0.41094 * frame.height))
        starPath.addLine(to: CGPoint(x: frame.minX + 14.64, y: frame.minY + 0.63343 * frame.height))
        starPath.addLine(to: CGPoint(x: frame.minX + 14.79, y: frame.minY + 0.91406 * frame.height))
        starPath.addLine(to: CGPoint(x: frame.minX + 9.5, y: frame.minY + 0.82000 * frame.height))
        starPath.addLine(to: CGPoint(x: frame.minX + 4.21, y: frame.minY + 0.91406 * frame.height))
        starPath.addLine(to: CGPoint(x: frame.minX + 4.36, y: frame.minY + 0.63343 * frame.height))
        starPath.addLine(to: CGPoint(x: frame.minX + 0.94, y: frame.minY + 0.41094 * frame.height))
        starPath.addLine(to: CGPoint(x: frame.minX + 6.33, y: frame.minY + 0.33157 * frame.height))
        starPath.close()
        NoodlesStyleKit.lighterGreen.setFill()
        starPath.fill()

        context.restoreGState()


        //// Star 2 Drawing
        context.saveGState()
        context.setBlendMode(.colorBurn)

        let star2Path = UIBezierPath()
        star2Path.move(to: CGPoint(x: frame.minX + 0.30000 * frame.width, y: frame.minY + 0.10000 * frame.height))
        star2Path.addLine(to: CGPoint(x: frame.minX + 0.33341 * frame.width, y: frame.minY + 0.33157 * frame.height))
        star2Path.addLine(to: CGPoint(x: frame.minX + 0.39010 * frame.width, y: frame.minY + 0.41094 * frame.height))
        star2Path.addLine(to: CGPoint(x: frame.minX + 0.35406 * frame.width, y: frame.minY + 0.63343 * frame.height))
        star2Path.addLine(to: CGPoint(x: frame.minX + 0.35568 * frame.width, y: frame.minY + 0.91406 * frame.height))
        star2Path.addLine(to: CGPoint(x: frame.minX + 0.30000 * frame.width, y: frame.minY + 0.82000 * frame.height))
        star2Path.addLine(to: CGPoint(x: frame.minX + 0.24432 * frame.width, y: frame.minY + 0.91406 * frame.height))
        star2Path.addLine(to: CGPoint(x: frame.minX + 0.24594 * frame.width, y: frame.minY + 0.63343 * frame.height))
        star2Path.addLine(to: CGPoint(x: frame.minX + 0.20990 * frame.width, y: frame.minY + 0.41094 * frame.height))
        star2Path.addLine(to: CGPoint(x: frame.minX + 0.26659 * frame.width, y: frame.minY + 0.33157 * frame.height))
        star2Path.close()
        NoodlesStyleKit.lighterGreen.setFill()
        star2Path.fill()

        context.restoreGState()


        //// Star 3 Drawing
        context.saveGState()
        context.setBlendMode(.colorBurn)

        let star3Path = UIBezierPath()
        star3Path.move(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.10000 * frame.height))
        star3Path.addLine(to: CGPoint(x: frame.minX + 0.53341 * frame.width, y: frame.minY + 0.33157 * frame.height))
        star3Path.addLine(to: CGPoint(x: frame.minX + 0.59010 * frame.width, y: frame.minY + 0.41094 * frame.height))
        star3Path.addLine(to: CGPoint(x: frame.minX + 0.55406 * frame.width, y: frame.minY + 0.63343 * frame.height))
        star3Path.addLine(to: CGPoint(x: frame.minX + 0.55568 * frame.width, y: frame.minY + 0.91406 * frame.height))
        star3Path.addLine(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.82000 * frame.height))
        star3Path.addLine(to: CGPoint(x: frame.minX + 0.44432 * frame.width, y: frame.minY + 0.91406 * frame.height))
        star3Path.addLine(to: CGPoint(x: frame.minX + 0.44594 * frame.width, y: frame.minY + 0.63343 * frame.height))
        star3Path.addLine(to: CGPoint(x: frame.minX + 0.40990 * frame.width, y: frame.minY + 0.41094 * frame.height))
        star3Path.addLine(to: CGPoint(x: frame.minX + 0.46659 * frame.width, y: frame.minY + 0.33157 * frame.height))
        star3Path.close()
        NoodlesStyleKit.lighterGreen.setFill()
        star3Path.fill()

        context.restoreGState()


        //// Star 4 Drawing
        context.saveGState()
        context.setBlendMode(.colorBurn)

        let star4Path = UIBezierPath()
        star4Path.move(to: CGPoint(x: frame.minX + 0.70000 * frame.width, y: frame.minY + 0.10000 * frame.height))
        star4Path.addLine(to: CGPoint(x: frame.minX + 0.73341 * frame.width, y: frame.minY + 0.33157 * frame.height))
        star4Path.addLine(to: CGPoint(x: frame.minX + 0.79010 * frame.width, y: frame.minY + 0.41094 * frame.height))
        star4Path.addLine(to: CGPoint(x: frame.minX + 0.75406 * frame.width, y: frame.minY + 0.63343 * frame.height))
        star4Path.addLine(to: CGPoint(x: frame.minX + 0.75568 * frame.width, y: frame.minY + 0.91406 * frame.height))
        star4Path.addLine(to: CGPoint(x: frame.minX + 0.70000 * frame.width, y: frame.minY + 0.82000 * frame.height))
        star4Path.addLine(to: CGPoint(x: frame.minX + 0.64432 * frame.width, y: frame.minY + 0.91406 * frame.height))
        star4Path.addLine(to: CGPoint(x: frame.minX + 0.64594 * frame.width, y: frame.minY + 0.63343 * frame.height))
        star4Path.addLine(to: CGPoint(x: frame.minX + 0.60990 * frame.width, y: frame.minY + 0.41094 * frame.height))
        star4Path.addLine(to: CGPoint(x: frame.minX + 0.66659 * frame.width, y: frame.minY + 0.33157 * frame.height))
        star4Path.close()
        NoodlesStyleKit.lighterGreen.setFill()
        star4Path.fill()

        context.restoreGState()


        //// Star 5 Drawing
        context.saveGState()
        context.setBlendMode(.colorBurn)

        let star5Path = UIBezierPath()
        star5Path.move(to: CGPoint(x: frame.maxX - 9.5, y: frame.minY + 0.10000 * frame.height))
        star5Path.addLine(to: CGPoint(x: frame.maxX - 6.33, y: frame.minY + 0.33157 * frame.height))
        star5Path.addLine(to: CGPoint(x: frame.maxX - 0.94, y: frame.minY + 0.41094 * frame.height))
        star5Path.addLine(to: CGPoint(x: frame.maxX - 4.36, y: frame.minY + 0.63343 * frame.height))
        star5Path.addLine(to: CGPoint(x: frame.maxX - 4.21, y: frame.minY + 0.91406 * frame.height))
        star5Path.addLine(to: CGPoint(x: frame.maxX - 9.5, y: frame.minY + 0.82000 * frame.height))
        star5Path.addLine(to: CGPoint(x: frame.maxX - 14.79, y: frame.minY + 0.91406 * frame.height))
        star5Path.addLine(to: CGPoint(x: frame.maxX - 14.64, y: frame.minY + 0.63343 * frame.height))
        star5Path.addLine(to: CGPoint(x: frame.maxX - 18.06, y: frame.minY + 0.41094 * frame.height))
        star5Path.addLine(to: CGPoint(x: frame.maxX - 12.67, y: frame.minY + 0.33157 * frame.height))
        star5Path.close()
        NoodlesStyleKit.lighterGreen.setFill()
        star5Path.fill()

        context.restoreGState()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: frame.minX + 95, y: frame.minY)
        context.scaleBy(x: ratingRatio, y: 1)

        context.saveGState()
        context.setBlendMode(.destinationOut)

        let rectanglePath = UIBezierPath(rect: CGRect(x: -95, y: 0, width: 95, height: 20))
        UIColor.gray.setFill()
        rectanglePath.fill()

        context.restoreGState()

        context.restoreGState()
    }

    public dynamic class func drawOnHandIndicator(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 21, height: 21), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 21, height: 21), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 21, y: resizedFrame.height / 21)


        //// Color Declarations
        let success = UIColor(red: 0.742, green: 0.927, blue: 0.079, alpha: 1.000)
        let successCheck = success.shadow(withLevel: 0.6)

        //// Rectangle 5 Drawing
        let rectangle5Path = UIBezierPath(rect: CGRect(x: 3, y: 3, width: 15, height: 15))
        NoodlesStyleKit.lighterYellow.setFill()
        rectangle5Path.fill()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 18, y: 3))
        bezierPath.addLine(to: CGPoint(x: 3, y: 3))
        bezierPath.addLine(to: CGPoint(x: 3, y: 18))
        bezierPath.addLine(to: CGPoint(x: 18, y: 18))
        bezierPath.addLine(to: CGPoint(x: 18, y: 3))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 20, y: 1))
        bezierPath.addCurve(to: CGPoint(x: 20, y: 20), controlPoint1: CGPoint(x: 20, y: 1), controlPoint2: CGPoint(x: 20, y: 20))
        bezierPath.addLine(to: CGPoint(x: 1, y: 20))
        bezierPath.addLine(to: CGPoint(x: 1, y: 1))
        bezierPath.addLine(to: CGPoint(x: 20, y: 1))
        bezierPath.addLine(to: CGPoint(x: 20, y: 1))
        bezierPath.close()
        NoodlesStyleKit.darkerGreen.setFill()
        bezierPath.fill()


        //// Group
        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 8.35, y: 14.85)
        context.rotate(by: -45 * CGFloat.pi/180)

        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: -0.47, y: -3.55, width: 1, height: 4), cornerRadius: 0.5)
        UIColor.gray.setFill()
        rectanglePath.fill()
        successCheck.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()

        context.restoreGState()


        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: 11.43, y: 10.57)
        context.rotate(by: 33.45 * CGFloat.pi/180)

        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: -0.5, y: -5.76, width: 1, height: 11.52), cornerRadius: 0.5)
        UIColor.gray.setFill()
        rectangle2Path.fill()
        successCheck.setStroke()
        rectangle2Path.lineWidth = 1
        rectangle2Path.stroke()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawOnHandIndicatorEmpty(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 21, height: 21), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 21, height: 21), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 21, y: resizedFrame.height / 21)


        //// Color Declarations
        let failure = UIColor(red: 0.896, green: 0.200, blue: 0.200, alpha: 1.000)
        let failureCross = failure.withBrightness(0.5)

        //// Rectangle 5 Drawing
        let rectangle5Path = UIBezierPath(rect: CGRect(x: 3, y: 3, width: 15, height: 15))
        NoodlesStyleKit.lighterYellow.setFill()
        rectangle5Path.fill()


        //// Rectangle 4 Drawing
        context.saveGState()
        context.translateBy(x: 10.51, y: 10.49)
        context.rotate(by: 45 * CGFloat.pi/180)

        let rectangle4Path = UIBezierPath(roundedRect: CGRect(x: -7.5, y: -1, width: 15, height: 2), cornerRadius: 1)
        failureCross.setFill()
        rectangle4Path.fill()

        context.restoreGState()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 18, y: 3))
        bezierPath.addLine(to: CGPoint(x: 3, y: 3))
        bezierPath.addLine(to: CGPoint(x: 3, y: 18))
        bezierPath.addLine(to: CGPoint(x: 18, y: 18))
        bezierPath.addLine(to: CGPoint(x: 18, y: 3))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 20, y: 1))
        bezierPath.addCurve(to: CGPoint(x: 20, y: 20), controlPoint1: CGPoint(x: 20, y: 1), controlPoint2: CGPoint(x: 20, y: 20))
        bezierPath.addLine(to: CGPoint(x: 1, y: 20))
        bezierPath.addLine(to: CGPoint(x: 1, y: 1))
        bezierPath.addLine(to: CGPoint(x: 20, y: 1))
        bezierPath.addLine(to: CGPoint(x: 20, y: 1))
        bezierPath.close()
        NoodlesStyleKit.darkerGreen.setFill()
        bezierPath.fill()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 10.51, y: 10.49)
        context.rotate(by: -45 * CGFloat.pi/180)

        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: -7.5, y: -1, width: 15, height: 2), cornerRadius: 1)
        failureCross.setFill()
        rectanglePath.fill()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawPause(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 75, height: 50), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 75, height: 50), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 75, y: resizedFrame.height / 50)


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: 20, y: 6, width: 13, height: 37))
        NoodlesStyleKit.darkerOrange.setFill()
        rectanglePath.fill()


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(rect: CGRect(x: 41, y: 6, width: 13, height: 37))
        NoodlesStyleKit.darkerOrange.setFill()
        rectangle2Path.fill()
        
        context.restoreGState()

    }

    public dynamic class func drawPlay(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 75, height: 50), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 75, height: 50), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 75, y: resizedFrame.height / 50)


        //// Polygon Drawing
        context.saveGState()
        context.translateBy(x: 36, y: 25.5)
        context.rotate(by: 90 * CGFloat.pi/180)

        let polygonPath = UIBezierPath()
        polygonPath.move(to: CGPoint(x: 0, y: -26.5))
        polygonPath.addLine(to: CGPoint(x: 18.62, y: 13.25))
        polygonPath.addLine(to: CGPoint(x: -18.62, y: 13.25))
        polygonPath.close()
        NoodlesStyleKit.darkerOrange.setFill()
        polygonPath.fill()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawCancel(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 75, height: 75), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 75, height: 75), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 75, y: resizedFrame.height / 75)


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 2, y: 2, width: 71, height: 71))
        NoodlesStyleKit.darkerOrange.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 38.42, y: 36.99)
        context.rotate(by: 45 * CGFloat.pi/180)

        let rectanglePath = UIBezierPath(rect: CGRect(x: -2.5, y: -23, width: 5, height: 46))
        NoodlesStyleKit.darkerOrange.setFill()
        rectanglePath.fill()

        context.restoreGState()


        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: 38.5, y: 37)
        context.rotate(by: -45 * CGFloat.pi/180)

        let rectangle2Path = UIBezierPath(rect: CGRect(x: -2.5, y: -23, width: 5, height: 46))
        NoodlesStyleKit.darkerOrange.setFill()
        rectangle2Path.fill()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawCancelSelected(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 75, height: 75), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 75, height: 75), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 75, y: resizedFrame.height / 75)


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 2, y: 2, width: 71, height: 71))
        NoodlesStyleKit.lighterOrange.setFill()
        ovalPath.fill()
        NoodlesStyleKit.darkerOrange.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 38.42, y: 36.99)
        context.rotate(by: 45 * CGFloat.pi/180)

        let rectanglePath = UIBezierPath(rect: CGRect(x: -2.5, y: -23, width: 5, height: 46))
        NoodlesStyleKit.darkerOrange.setFill()
        rectanglePath.fill()

        context.restoreGState()


        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: 38.5, y: 37)
        context.rotate(by: -45 * CGFloat.pi/180)

        let rectangle2Path = UIBezierPath(rect: CGRect(x: -2.5, y: -23, width: 5, height: 46))
        NoodlesStyleKit.darkerOrange.setFill()
        rectangle2Path.fill()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawTimerButton(frame: CGRect = CGRect(x: 0, y: 0, width: 240, height: 75), timerButtonLabel: String = "Start Timer") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: frame.minX + fastFloor(frame.width * 0.00417 + 0.5), y: frame.minY + 1, width: fastFloor(frame.width * 0.99583 + 0.5) - fastFloor(frame.width * 0.00417 + 0.5), height: 73), cornerRadius: 6)
        NoodlesStyleKit.lighterGreen.setFill()
        rectanglePath.fill()
        NoodlesStyleKit.darkerGreen.setStroke()
        rectanglePath.lineWidth = 3
        rectanglePath.stroke()


        //// Text Drawing
        let textRect = CGRect(x: frame.minX + fastFloor((frame.width - 216) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 35) * 0.50000 + 0.5), width: 216, height: 35)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [NSFontAttributeName: UIFont.systemFont(ofSize: 24), NSForegroundColorAttributeName: UIColor.black, NSParagraphStyleAttributeName: textStyle]

        let textTextHeight: CGFloat = timerButtonLabel.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        timerButtonLabel.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
    }

    public dynamic class func drawTimerButtonSelected(frame: CGRect = CGRect(x: 0, y: 0, width: 240, height: 75), timerButtonLabel: String = "Start Timer") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: frame.minX + fastFloor(frame.width * 0.00417 + 0.5), y: frame.minY + 1, width: fastFloor(frame.width * 0.99583 + 0.5) - fastFloor(frame.width * 0.00417 + 0.5), height: 73), cornerRadius: 6)
        NoodlesStyleKit.darkerGreen.setFill()
        rectanglePath.fill()
        NoodlesStyleKit.darkerGreen.setStroke()
        rectanglePath.lineWidth = 3
        rectanglePath.stroke()


        //// Text Drawing
        let textRect = CGRect(x: frame.minX + fastFloor((frame.width - 216) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 35) * 0.50000 + 0.5), width: 216, height: 35)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [NSFontAttributeName: UIFont.systemFont(ofSize: 24), NSForegroundColorAttributeName: UIColor.black, NSParagraphStyleAttributeName: textStyle]

        let textTextHeight: CGFloat = timerButtonLabel.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        timerButtonLabel.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
    }

    public dynamic class func drawNoodlePlaceholderImage(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 144, height: 144), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 144, height: 144), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 144, y: resizedFrame.height / 144)


        //// Color Declarations
        let mediumOrange = NoodlesStyleKit.baseOrange.highlight(withLevel: 0.1)

        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 144, height: 144))
        NoodlesStyleKit.lighterYellow.setFill()
        rectangle4Path.fill()


        //// Group
        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: 35, y: 73.17)

        let rectangle2Path = UIBezierPath(rect: CGRect(x: -18, y: -40.57, width: 36, height: 81.15))
        NoodlesStyleKit.baseOrange.setFill()
        rectangle2Path.fill()

        context.restoreGState()


        //// Rectangle 3 Drawing
        context.saveGState()
        context.translateBy(x: 109, y: 75.54)

        let rectangle3Path = UIBezierPath(rect: CGRect(x: -18, y: -38.69, width: 36, height: 77.38))
        NoodlesStyleKit.baseOrange.setFill()
        rectangle3Path.fill()

        context.restoreGState()


        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalIn: CGRect(x: 17, y: 16, width: 36, height: 36))
        NoodlesStyleKit.lighterOrange.setFill()
        oval3Path.fill()


        //// Oval 4 Drawing
        let oval4Path = UIBezierPath(ovalIn: CGRect(x: 91, y: 90.5, width: 36, height: 36))
        NoodlesStyleKit.lighterOrange.setFill()
        oval4Path.fill()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: 74, y: 73.84)
        context.rotate(by: -45 * CGFloat.pi/180)

        let rectanglePath = UIBezierPath(rect: CGRect(x: -17.5, y: -53.35, width: 35, height: 106.7))
        NoodlesStyleKit.lighterOrange.setFill()
        rectanglePath.fill()

        context.restoreGState()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 17, y: 92, width: 36, height: 36))
        NoodlesStyleKit.baseOrange.setFill()
        ovalPath.fill()
        NoodlesStyleKit.lighterOrange.setStroke()
        ovalPath.lineWidth = 0.5
        ovalPath.stroke()


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: 90.75, y: 16, width: 36, height: 37))
        NoodlesStyleKit.baseOrange.setFill()
        oval2Path.fill()
        NoodlesStyleKit.lighterOrange.setStroke()
        oval2Path.lineWidth = 0.5
        oval2Path.stroke()


        //// Oval 5 Drawing
        let oval5Path = UIBezierPath(ovalIn: CGRect(x: 96.25, y: 21.5, width: 25, height: 26))
        NoodlesStyleKit.lighterOrange.setFill()
        oval5Path.fill()
        NoodlesStyleKit.lighterOrange.setStroke()
        oval5Path.lineWidth = 0.5
        oval5Path.stroke()


        //// Oval 6 Drawing
        let oval6Path = UIBezierPath(ovalIn: CGRect(x: 22.5, y: 97, width: 25, height: 26))
        NoodlesStyleKit.lighterOrange.setFill()
        oval6Path.fill()
        NoodlesStyleKit.lighterOrange.setStroke()
        oval6Path.lineWidth = 0.5
        oval6Path.stroke()


        //// Bezier 3 Drawing
        context.saveGState()
        context.translateBy(x: 58.01, y: 80.5)
        context.rotate(by: -45 * CGFloat.pi/180)

        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: -0.01, y: -49.68))
        bezier3Path.addCurve(to: CGPoint(x: -0.01, y: 59.44), controlPoint1: CGPoint(x: -0.01, y: 59.44), controlPoint2: CGPoint(x: -0.01, y: 59.44))
        bezier3Path.addLine(to: CGPoint(x: -0.01, y: 59.44))
        mediumOrange.setStroke()
        bezier3Path.lineWidth = 3
        bezier3Path.lineCapStyle = .round
        bezier3Path.stroke()

        context.restoreGState()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 19, y: 56.57))
        bezier4Path.addCurve(to: CGPoint(x: 19, y: 93.46), controlPoint1: CGPoint(x: 19, y: 93.46), controlPoint2: CGPoint(x: 19, y: 93.46))
        bezier4Path.addLine(to: CGPoint(x: 19, y: 93.46))
        mediumOrange.setStroke()
        bezier4Path.lineWidth = 3
        bezier4Path.lineCapStyle = .round
        bezier4Path.stroke()


        //// Bezier 2 Drawing
        context.saveGState()
        context.translateBy(x: 83.67, y: 60)
        context.rotate(by: -45 * CGFloat.pi/180)

        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 0, y: -53.91))
        bezier2Path.addCurve(to: CGPoint(x: 0, y: 52.61), controlPoint1: CGPoint(x: 0, y: 52.61), controlPoint2: CGPoint(x: 0, y: 52.61))
        bezier2Path.addLine(to: CGPoint(x: 0, y: 52.61))
        mediumOrange.setStroke()
        bezier2Path.lineWidth = 3
        bezier2Path.lineCapStyle = .round
        bezier2Path.stroke()

        context.restoreGState()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 125, y: 56.57))
        bezierPath.addCurve(to: CGPoint(x: 125, y: 93.46), controlPoint1: CGPoint(x: 125, y: 93.46), controlPoint2: CGPoint(x: 125, y: 93.46))
        bezierPath.addLine(to: CGPoint(x: 125, y: 93.46))
        mediumOrange.setStroke()
        bezierPath.lineWidth = 3
        bezierPath.lineCapStyle = .round
        bezierPath.stroke()


        //// Oval 8 Drawing
        context.saveGState()
        context.translateBy(x: 126.34, y: 126)
        context.rotate(by: -180 * CGFloat.pi/180)

        let oval8Path = UIBezierPath()
        oval8Path.move(to: CGPoint(x: 4.88, y: 28.01))
        oval8Path.addCurve(to: CGPoint(x: -0, y: 16.32), controlPoint1: CGPoint(x: 1.87, y: 25.05), controlPoint2: CGPoint(x: -0, y: 20.9))
        oval8Path.addCurve(to: CGPoint(x: 16.17, y: 0), controlPoint1: CGPoint(x: -0, y: 7.31), controlPoint2: CGPoint(x: 7.24, y: 0))
        oval8Path.addCurve(to: CGPoint(x: 27.84, y: 5.03), controlPoint1: CGPoint(x: 20.75, y: 0), controlPoint2: CGPoint(x: 24.9, y: 1.93))
        mediumOrange.setStroke()
        oval8Path.lineWidth = 3
        oval8Path.lineCapStyle = .round
        oval8Path.stroke()

        context.restoreGState()


        //// Oval 7 Drawing
        let oval7Path = UIBezierPath()
        oval7Path.move(to: CGPoint(x: 22.69, y: 44.51))
        oval7Path.addCurve(to: CGPoint(x: 18, y: 33.03), controlPoint1: CGPoint(x: 19.8, y: 41.6), controlPoint2: CGPoint(x: 18, y: 37.53))
        oval7Path.addCurve(to: CGPoint(x: 33.53, y: 17), controlPoint1: CGPoint(x: 18, y: 24.18), controlPoint2: CGPoint(x: 24.95, y: 17))
        oval7Path.addCurve(to: CGPoint(x: 44.74, y: 21.94), controlPoint1: CGPoint(x: 37.94, y: 17), controlPoint2: CGPoint(x: 41.91, y: 18.9))
        mediumOrange.setStroke()
        oval7Path.lineWidth = 3
        oval7Path.lineCapStyle = .round
        oval7Path.stroke()
        
        context.restoreGState()

    }

    //// Generated Images

    public dynamic class func imageOfTimerAnimation(timerRatio: CGFloat = 0) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 200, height: 200), false, 0)
            NoodlesStyleKit.drawTimerAnimation(timerRatio: timerRatio)

        let imageOfTimerAnimation = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfTimerAnimation
    }

    public dynamic class var imageOfScanFailure: UIImage {
        if Cache.imageOfScanFailure != nil {
            return Cache.imageOfScanFailure!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 75, height: 75), false, 0)
            NoodlesStyleKit.drawScanFailure()

        Cache.imageOfScanFailure = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfScanFailure!
    }

    public dynamic class var imageOfScanSuccess: UIImage {
        if Cache.imageOfScanSuccess != nil {
            return Cache.imageOfScanSuccess!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 75, height: 75), false, 0)
            NoodlesStyleKit.drawScanSuccess()

        Cache.imageOfScanSuccess = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfScanSuccess!
    }

    public dynamic class var imageOfScanProcessing: UIImage {
        if Cache.imageOfScanProcessing != nil {
            return Cache.imageOfScanProcessing!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 75, height: 75), false, 0)
            NoodlesStyleKit.drawScanProcessing()

        Cache.imageOfScanProcessing = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfScanProcessing!
    }

    public dynamic class var imageOfNouille: UIImage {
        if Cache.imageOfNouille != nil {
            return Cache.imageOfNouille!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 40, height: 40), false, 0)
            NoodlesStyleKit.drawNouille()

        Cache.imageOfNouille = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfNouille!
    }

    public dynamic class var imageOfMealSizeIndicator: UIImage {
        if Cache.imageOfMealSizeIndicator != nil {
            return Cache.imageOfMealSizeIndicator!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 40, height: 40), false, 0)
            NoodlesStyleKit.drawMealSizeIndicator()

        Cache.imageOfMealSizeIndicator = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfMealSizeIndicator!
    }

    public dynamic class var imageOfMealSizeIndicatorSD: UIImage {
        if Cache.imageOfMealSizeIndicatorSD != nil {
            return Cache.imageOfMealSizeIndicatorSD!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 40, height: 40), false, 0)
            NoodlesStyleKit.drawMealSizeIndicatorSD()

        Cache.imageOfMealSizeIndicatorSD = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfMealSizeIndicatorSD!
    }

    public dynamic class func imageOfRatingIndicator(imageSize: CGSize = CGSize(width: 95, height: 20), rating: CGFloat = 2) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            NoodlesStyleKit.drawRatingIndicator(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), rating: rating)

        let imageOfRatingIndicator = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfRatingIndicator
    }

    public dynamic class var imageOfOnHandIndicator: UIImage {
        if Cache.imageOfOnHandIndicator != nil {
            return Cache.imageOfOnHandIndicator!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 21, height: 21), false, 0)
            NoodlesStyleKit.drawOnHandIndicator()

        Cache.imageOfOnHandIndicator = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfOnHandIndicator!
    }

    public dynamic class var imageOfOnHandIndicatorEmpty: UIImage {
        if Cache.imageOfOnHandIndicatorEmpty != nil {
            return Cache.imageOfOnHandIndicatorEmpty!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 21, height: 21), false, 0)
            NoodlesStyleKit.drawOnHandIndicatorEmpty()

        Cache.imageOfOnHandIndicatorEmpty = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfOnHandIndicatorEmpty!
    }

    public dynamic class var imageOfPause: UIImage {
        if Cache.imageOfPause != nil {
            return Cache.imageOfPause!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 75, height: 50), false, 0)
            NoodlesStyleKit.drawPause()

        Cache.imageOfPause = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfPause!
    }

    public dynamic class var imageOfPlay: UIImage {
        if Cache.imageOfPlay != nil {
            return Cache.imageOfPlay!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 75, height: 50), false, 0)
            NoodlesStyleKit.drawPlay()

        Cache.imageOfPlay = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfPlay!
    }

    public dynamic class var imageOfCancel: UIImage {
        if Cache.imageOfCancel != nil {
            return Cache.imageOfCancel!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 75, height: 75), false, 0)
            NoodlesStyleKit.drawCancel()

        Cache.imageOfCancel = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfCancel!
    }

    public dynamic class var imageOfCancelSelected: UIImage {
        if Cache.imageOfCancelSelected != nil {
            return Cache.imageOfCancelSelected!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 75, height: 75), false, 0)
            NoodlesStyleKit.drawCancelSelected()

        Cache.imageOfCancelSelected = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfCancelSelected!
    }

    public dynamic class func imageOfTimerButton(imageSize: CGSize = CGSize(width: 240, height: 75), timerButtonLabel: String = "Start Timer") -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            NoodlesStyleKit.drawTimerButton(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), timerButtonLabel: timerButtonLabel)

        let imageOfTimerButton = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfTimerButton
    }

    public dynamic class func imageOfTimerButtonSelected(imageSize: CGSize = CGSize(width: 240, height: 75), timerButtonLabel: String = "Start Timer") -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            NoodlesStyleKit.drawTimerButtonSelected(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), timerButtonLabel: timerButtonLabel)

        let imageOfTimerButtonSelected = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfTimerButtonSelected
    }

    public dynamic class var imageOfNoodlePlaceholderImage: UIImage {
        if Cache.imageOfNoodlePlaceholderImage != nil {
            return Cache.imageOfNoodlePlaceholderImage!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 144, height: 144), false, 0)
            NoodlesStyleKit.drawNoodlePlaceholderImage()

        Cache.imageOfNoodlePlaceholderImage = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfNoodlePlaceholderImage!
    }

    //// Customization Infrastructure

    @IBOutlet dynamic var scanFailureTargets: [AnyObject]! {
        get { return Cache.scanFailureTargets }
        set {
            Cache.scanFailureTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: NoodlesStyleKit.imageOfScanFailure)
            }
        }
    }

    @IBOutlet dynamic var scanSuccessTargets: [AnyObject]! {
        get { return Cache.scanSuccessTargets }
        set {
            Cache.scanSuccessTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setSelectedImage:"), with: NoodlesStyleKit.imageOfScanSuccess)
            }
        }
    }

    @IBOutlet dynamic var scanProcessingTargets: [AnyObject]! {
        get { return Cache.scanProcessingTargets }
        set {
            Cache.scanProcessingTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: NoodlesStyleKit.imageOfScanProcessing)
            }
        }
    }

    @IBOutlet dynamic var nouilleTargets: [AnyObject]! {
        get { return Cache.nouilleTargets }
        set {
            Cache.nouilleTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: NoodlesStyleKit.imageOfNouille)
            }
        }
    }

    @IBOutlet dynamic var mealSizeIndicatorTargets: [AnyObject]! {
        get { return Cache.mealSizeIndicatorTargets }
        set {
            Cache.mealSizeIndicatorTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setSelectedImage:"), with: NoodlesStyleKit.imageOfMealSizeIndicator)
            }
        }
    }

    @IBOutlet dynamic var mealSizeIndicatorSDTargets: [AnyObject]! {
        get { return Cache.mealSizeIndicatorSDTargets }
        set {
            Cache.mealSizeIndicatorSDTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: NoodlesStyleKit.imageOfMealSizeIndicatorSD)
            }
        }
    }

    @IBOutlet dynamic var onHandIndicatorTargets: [AnyObject]! {
        get { return Cache.onHandIndicatorTargets }
        set {
            Cache.onHandIndicatorTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setSelectedImage:"), with: NoodlesStyleKit.imageOfOnHandIndicator)
            }
        }
    }

    @IBOutlet dynamic var onHandIndicatorEmptyTargets: [AnyObject]! {
        get { return Cache.onHandIndicatorEmptyTargets }
        set {
            Cache.onHandIndicatorEmptyTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: NoodlesStyleKit.imageOfOnHandIndicatorEmpty)
            }
        }
    }

    @IBOutlet dynamic var pauseTargets: [AnyObject]! {
        get { return Cache.pauseTargets }
        set {
            Cache.pauseTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: NoodlesStyleKit.imageOfPause)
            }
        }
    }

    @IBOutlet dynamic var playTargets: [AnyObject]! {
        get { return Cache.playTargets }
        set {
            Cache.playTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setSelectedImage:"), with: NoodlesStyleKit.imageOfPlay)
            }
        }
    }

    @IBOutlet dynamic var cancelTargets: [AnyObject]! {
        get { return Cache.cancelTargets }
        set {
            Cache.cancelTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: NoodlesStyleKit.imageOfCancel)
            }
        }
    }

    @IBOutlet dynamic var cancelSelectedTargets: [AnyObject]! {
        get { return Cache.cancelSelectedTargets }
        set {
            Cache.cancelSelectedTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setSelectedImage:"), with: NoodlesStyleKit.imageOfCancelSelected)
            }
        }
    }

    @IBOutlet dynamic var noodlePlaceholderImageTargets: [AnyObject]! {
        get { return Cache.noodlePlaceholderImageTargets }
        set {
            Cache.noodlePlaceholderImageTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: NoodlesStyleKit.imageOfNoodlePlaceholderImage)
            }
        }
    }




    @objc public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



extension UIColor {
    func withHue(_ newHue: CGFloat) -> UIColor {
        var saturation: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
    func withSaturation(_ newSaturation: CGFloat) -> UIColor {
        var hue: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
    }
    func withBrightness(_ newBrightness: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
        return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
    }
    func withAlpha(_ newAlpha: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, brightness: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
        return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
    }
    func highlight(withLevel highlight: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-highlight) + highlight, green: green * (1-highlight) + highlight, blue: blue * (1-highlight) + highlight, alpha: alpha * (1-highlight) + highlight)
    }
    func shadow(withLevel shadow: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
    }
}
